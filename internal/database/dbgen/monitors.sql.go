// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: monitors.sql

package dbgen

import (
	"context"
	"encoding/json"
	"net/netip"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createMonitor = `-- name: CreateMonitor :one
INSERT INTO monitors (
    display_name,
    hostname,
    ip_address,
    plugin_id,
    credential_profile_id,
    discovery_profile_id,
    port,
    polling_interval_seconds,
    status
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, 
    COALESCE($8::int, 60), 
    COALESCE($9::text, 'active')
)
RETURNING id, display_name, hostname, ip_address, plugin_id, credential_profile_id, discovery_profile_id, polling_interval_seconds, status, created_at, updated_at, deleted_at, port
`

type CreateMonitorParams struct {
	DisplayName            pgtype.Text `json:"display_name"`
	Hostname               pgtype.Text `json:"hostname"`
	IpAddress              netip.Addr  `json:"ip_address"`
	PluginID               string      `json:"plugin_id"`
	CredentialProfileID    uuid.UUID   `json:"credential_profile_id"`
	DiscoveryProfileID     uuid.UUID   `json:"discovery_profile_id"`
	Port                   pgtype.Int4 `json:"port"`
	PollingIntervalSeconds pgtype.Int4 `json:"polling_interval_seconds"`
	Status                 pgtype.Text `json:"status"`
}

func (q *Queries) CreateMonitor(ctx context.Context, arg CreateMonitorParams) (Monitor, error) {
	row := q.db.QueryRow(ctx, createMonitor,
		arg.DisplayName,
		arg.Hostname,
		arg.IpAddress,
		arg.PluginID,
		arg.CredentialProfileID,
		arg.DiscoveryProfileID,
		arg.Port,
		arg.PollingIntervalSeconds,
		arg.Status,
	)
	var i Monitor
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Hostname,
		&i.IpAddress,
		&i.PluginID,
		&i.CredentialProfileID,
		&i.DiscoveryProfileID,
		&i.PollingIntervalSeconds,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Port,
	)
	return i, err
}

const deleteMonitor = `-- name: DeleteMonitor :exec
UPDATE monitors
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteMonitor(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteMonitor, id)
	return err
}

const getExistingMonitorIDs = `-- name: GetExistingMonitorIDs :many
SELECT id FROM monitors WHERE id = ANY($1::uuid[]) AND deleted_at IS NULL
`

// Returns only monitor IDs that exist and are not soft-deleted.
// Used to validate a batch of IDs before metrics queries.
func (q *Queries) GetExistingMonitorIDs(ctx context.Context, monitorIds []uuid.UUID) ([]uuid.UUID, error) {
	rows, err := q.db.Query(ctx, getExistingMonitorIDs, monitorIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMonitor = `-- name: GetMonitor :one
SELECT id, display_name, hostname, ip_address, plugin_id, credential_profile_id, discovery_profile_id, polling_interval_seconds, status, created_at, updated_at, deleted_at, port FROM monitors
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetMonitor(ctx context.Context, id uuid.UUID) (Monitor, error) {
	row := q.db.QueryRow(ctx, getMonitor, id)
	var i Monitor
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Hostname,
		&i.IpAddress,
		&i.PluginID,
		&i.CredentialProfileID,
		&i.DiscoveryProfileID,
		&i.PollingIntervalSeconds,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Port,
	)
	return i, err
}

const listActiveMonitorsWithCredentials = `-- name: ListActiveMonitorsWithCredentials :many
SELECT 
    m.id, m.display_name, m.hostname, m.ip_address, m.plugin_id, 
    m.credential_profile_id, m.discovery_profile_id, m.port, 
    m.polling_interval_seconds, m.status, m.created_at, m.updated_at, m.deleted_at,
    c.credential_data
FROM monitors m
JOIN credential_profiles c ON m.credential_profile_id = c.id
WHERE m.status = 'active' AND m.deleted_at IS NULL
`

type ListActiveMonitorsWithCredentialsRow struct {
	ID                     uuid.UUID          `json:"id"`
	DisplayName            pgtype.Text        `json:"display_name"`
	Hostname               pgtype.Text        `json:"hostname"`
	IpAddress              netip.Addr         `json:"ip_address"`
	PluginID               string             `json:"plugin_id"`
	CredentialProfileID    uuid.UUID          `json:"credential_profile_id"`
	DiscoveryProfileID     uuid.UUID          `json:"discovery_profile_id"`
	Port                   pgtype.Int4        `json:"port"`
	PollingIntervalSeconds pgtype.Int4        `json:"polling_interval_seconds"`
	Status                 pgtype.Text        `json:"status"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	DeletedAt              pgtype.Timestamptz `json:"deleted_at"`
	CredentialData         json.RawMessage    `json:"credential_data"`
}

// Loads active monitors with their credential data in a single query.
// Used by scheduler to initialize cache at startup.
func (q *Queries) ListActiveMonitorsWithCredentials(ctx context.Context) ([]ListActiveMonitorsWithCredentialsRow, error) {
	rows, err := q.db.Query(ctx, listActiveMonitorsWithCredentials)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListActiveMonitorsWithCredentialsRow
	for rows.Next() {
		var i ListActiveMonitorsWithCredentialsRow
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.Hostname,
			&i.IpAddress,
			&i.PluginID,
			&i.CredentialProfileID,
			&i.DiscoveryProfileID,
			&i.Port,
			&i.PollingIntervalSeconds,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CredentialData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMonitors = `-- name: ListMonitors :many
SELECT id, display_name, hostname, ip_address, plugin_id, credential_profile_id, discovery_profile_id, polling_interval_seconds, status, created_at, updated_at, deleted_at, port FROM monitors
WHERE deleted_at IS NULL
ORDER BY created_at DESC
`

func (q *Queries) ListMonitors(ctx context.Context) ([]Monitor, error) {
	rows, err := q.db.Query(ctx, listMonitors)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Monitor
	for rows.Next() {
		var i Monitor
		if err := rows.Scan(
			&i.ID,
			&i.DisplayName,
			&i.Hostname,
			&i.IpAddress,
			&i.PluginID,
			&i.CredentialProfileID,
			&i.DiscoveryProfileID,
			&i.PollingIntervalSeconds,
			&i.Status,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Port,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMonitor = `-- name: UpdateMonitor :one
UPDATE monitors
SET 
    display_name = $2,
    hostname = $3,
    ip_address = $4,
    plugin_id = $5,
    credential_profile_id = $6,
    polling_interval_seconds = $7,
    port = $8,
    status = $9,
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
RETURNING id, display_name, hostname, ip_address, plugin_id, credential_profile_id, discovery_profile_id, polling_interval_seconds, status, created_at, updated_at, deleted_at, port
`

type UpdateMonitorParams struct {
	ID                     uuid.UUID   `json:"id"`
	DisplayName            pgtype.Text `json:"display_name"`
	Hostname               pgtype.Text `json:"hostname"`
	IpAddress              netip.Addr  `json:"ip_address"`
	PluginID               string      `json:"plugin_id"`
	CredentialProfileID    uuid.UUID   `json:"credential_profile_id"`
	PollingIntervalSeconds pgtype.Int4 `json:"polling_interval_seconds"`
	Port                   pgtype.Int4 `json:"port"`
	Status                 pgtype.Text `json:"status"`
}

func (q *Queries) UpdateMonitor(ctx context.Context, arg UpdateMonitorParams) (Monitor, error) {
	row := q.db.QueryRow(ctx, updateMonitor,
		arg.ID,
		arg.DisplayName,
		arg.Hostname,
		arg.IpAddress,
		arg.PluginID,
		arg.CredentialProfileID,
		arg.PollingIntervalSeconds,
		arg.Port,
		arg.Status,
	)
	var i Monitor
	err := row.Scan(
		&i.ID,
		&i.DisplayName,
		&i.Hostname,
		&i.IpAddress,
		&i.PluginID,
		&i.CredentialProfileID,
		&i.DiscoveryProfileID,
		&i.PollingIntervalSeconds,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Port,
	)
	return i, err
}

const updateMonitorStatus = `-- name: UpdateMonitorStatus :exec
UPDATE monitors
SET status = $2, updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

type UpdateMonitorStatusParams struct {
	ID     uuid.UUID   `json:"id"`
	Status pgtype.Text `json:"status"`
}

// Updates monitor status (active/down) and updated_at timestamp.
func (q *Queries) UpdateMonitorStatus(ctx context.Context, arg UpdateMonitorStatusParams) error {
	_, err := q.db.Exec(ctx, updateMonitorStatus, arg.ID, arg.Status)
	return err
}
