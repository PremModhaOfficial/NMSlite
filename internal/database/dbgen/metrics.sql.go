// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: metrics.sql

package dbgen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getAllMetricNames = `-- name: GetAllMetricNames :many
SELECT DISTINCT name
FROM metrics
WHERE device_id = ANY($1::uuid[])
ORDER BY name
`

// Get all unique metric names (for discovery/autocomplete)
func (q *Queries) GetAllMetricNames(ctx context.Context, deviceIds []uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllMetricNames, deviceIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestMetricsByDeviceAndPrefix = `-- name: GetLatestMetricsByDeviceAndPrefix :many
SELECT DISTINCT ON (device_id, name)
       timestamp, device_id, name, value, type
FROM metrics
WHERE device_id = ANY($1::uuid[])
  AND name LIKE $2
  AND timestamp >= $3
  AND timestamp <= $4
ORDER BY device_id, name, timestamp DESC
`

type GetLatestMetricsByDeviceAndPrefixParams struct {
	DeviceIds         []uuid.UUID        `json:"device_ids"`
	MetricNamePattern string             `json:"metric_name_pattern"`
	StartTime         pgtype.Timestamptz `json:"start_time"`
	EndTime           pgtype.Timestamptz `json:"end_time"`
}

// Query the latest value for each metric (per device) with prefix matching
func (q *Queries) GetLatestMetricsByDeviceAndPrefix(ctx context.Context, arg GetLatestMetricsByDeviceAndPrefixParams) ([]Metric, error) {
	rows, err := q.db.Query(ctx, getLatestMetricsByDeviceAndPrefix,
		arg.DeviceIds,
		arg.MetricNamePattern,
		arg.StartTime,
		arg.EndTime,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Metric
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.Timestamp,
			&i.DeviceID,
			&i.Name,
			&i.Value,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricsByDeviceAndPrefix = `-- name: GetMetricsByDeviceAndPrefix :many
SELECT m.timestamp, m.device_id, m.name, m.value, m.type
FROM (
  SELECT DISTINCT metrics.device_id, metrics.name
  FROM metrics
  WHERE metrics.device_id = ANY($1::uuid[])
    AND metrics.name LIKE $2
    AND metrics.timestamp >= $3
    AND metrics.timestamp <= $4
) groups
CROSS JOIN LATERAL (
  SELECT metrics.timestamp, metrics.device_id, metrics.name, metrics.value, metrics.type
  FROM metrics
  WHERE metrics.device_id = groups.device_id
    AND metrics.name = groups.name
    AND metrics.timestamp >= $3
    AND metrics.timestamp <= $4
  ORDER BY metrics.timestamp DESC
  LIMIT $5
) m
ORDER BY m.device_id, m.name, m.timestamp DESC
`

type GetMetricsByDeviceAndPrefixParams struct {
	DeviceIds         []uuid.UUID        `json:"device_ids"`
	MetricNamePattern string             `json:"metric_name_pattern"`
	StartTime         pgtype.Timestamptz `json:"start_time"`
	EndTime           pgtype.Timestamptz `json:"end_time"`
	LimitCount        int32              `json:"limit_count"`
}

// Query metrics for devices with per-metric limiting using LATERAL JOIN
// Returns top N rows per (device_id, metric_name) group ordered by timestamp DESC
func (q *Queries) GetMetricsByDeviceAndPrefix(ctx context.Context, arg GetMetricsByDeviceAndPrefixParams) ([]Metric, error) {
	rows, err := q.db.Query(ctx, getMetricsByDeviceAndPrefix,
		arg.DeviceIds,
		arg.MetricNamePattern,
		arg.StartTime,
		arg.EndTime,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Metric
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.Timestamp,
			&i.DeviceID,
			&i.Name,
			&i.Value,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
