// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: metrics.sql

package dbgen

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getAllMetricNames = `-- name: GetAllMetricNames :many
SELECT DISTINCT name
FROM metrics
WHERE device_id = ANY($1::uuid[])
ORDER BY name
`

// Get all unique metric names (for discovery/autocomplete)
func (q *Queries) GetAllMetricNames(ctx context.Context, dollar_1 []uuid.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getAllMetricNames, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var name string
		if err := rows.Scan(&name); err != nil {
			return nil, err
		}
		items = append(items, name)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestMetricsByDeviceAndPrefix = `-- name: GetLatestMetricsByDeviceAndPrefix :many
SELECT DISTINCT ON (device_id, name)
       timestamp, device_id, name, value, type
FROM metrics
WHERE device_id = ANY($1::uuid[])
  AND name LIKE $2
  AND timestamp >= $3
  AND timestamp <= $4
ORDER BY device_id, name, timestamp DESC
`

type GetLatestMetricsByDeviceAndPrefixParams struct {
	Column1     []uuid.UUID        `json:"column_1"`
	Name        string             `json:"name"`
	Timestamp   pgtype.Timestamptz `json:"timestamp"`
	Timestamp_2 pgtype.Timestamptz `json:"timestamp_2"`
}

// Query the latest value for each metric (per device) with prefix matching
func (q *Queries) GetLatestMetricsByDeviceAndPrefix(ctx context.Context, arg GetLatestMetricsByDeviceAndPrefixParams) ([]Metric, error) {
	rows, err := q.db.Query(ctx, getLatestMetricsByDeviceAndPrefix,
		arg.Column1,
		arg.Name,
		arg.Timestamp,
		arg.Timestamp_2,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Metric
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.Timestamp,
			&i.DeviceID,
			&i.Name,
			&i.Value,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMetricsByDeviceAndPrefix = `-- name: GetMetricsByDeviceAndPrefix :many
SELECT timestamp, device_id, name, value, type
FROM metrics
WHERE device_id = ANY($1::uuid[])
  AND name LIKE $2  -- e.g., 'system.%' for subtree
  AND timestamp >= $3
  AND timestamp <= $4
ORDER BY timestamp DESC
LIMIT $5
`

type GetMetricsByDeviceAndPrefixParams struct {
	Column1     []uuid.UUID        `json:"column_1"`
	Name        string             `json:"name"`
	Timestamp   pgtype.Timestamptz `json:"timestamp"`
	Timestamp_2 pgtype.Timestamptz `json:"timestamp_2"`
	Limit       int32              `json:"limit"`
}

// Query metrics for devices with prefix matching (SNMP subtree style)
func (q *Queries) GetMetricsByDeviceAndPrefix(ctx context.Context, arg GetMetricsByDeviceAndPrefixParams) ([]Metric, error) {
	rows, err := q.db.Query(ctx, getMetricsByDeviceAndPrefix,
		arg.Column1,
		arg.Name,
		arg.Timestamp,
		arg.Timestamp_2,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Metric
	for rows.Next() {
		var i Metric
		if err := rows.Scan(
			&i.Timestamp,
			&i.DeviceID,
			&i.Name,
			&i.Value,
			&i.Type,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
